package io.realm;
import android.text.TextUtils;
import java.util.Collections;
import java.util.Date;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import io.realm.annotations.Beta;
import io.realm.annotations.Required;
import io.realm.internal.CheckedRow;
import io.realm.internal.ObjectServerFacade;
import io.realm.internal.OsList;
import io.realm.internal.OsResults;
import io.realm.internal.PendingRow;
import io.realm.internal.annotations.ObjectServer;
import io.realm.internal.core.IncludeDescriptor;
import io.realm.internal.core.QueryDescriptor;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.Row;
import io.realm.internal.SubscriptionAwareOsResults;
import io.realm.internal.Table;
import io.realm.internal.TableQuery;
import io.realm.internal.Util;
import io.realm.internal.core.DescriptorOrdering;
import io.realm.internal.fields.FieldDescriptor;
import io.realm.internal.sync.SubscriptionAction;
import io.realm.sync.Subscription;
public class RealmQuery<E> {
private final Table table;
private final BaseRealm realm;
private final TableQuery query;
private final RealmObjectSchema schema;
private Class<E> clazz;
private String className;
private final boolean forValues;
private final OsList osList;
private DescriptorOrdering queryDescriptors = new DescriptorOrdering();
private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
private static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
return new RealmQuery<>(realm, clazz);
}
static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
return new RealmQuery<>(realm, className);
}
@SuppressWarnings("unchecked")
static <E> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
return (queryResults.classSpec == null)
? new RealmQuery(queryResults, queryResults.className)
: new RealmQuery<>(queryResults, queryResults.classSpec);
}
@SuppressWarnings("unchecked")
static <E> RealmQuery<E> createQueryFromList(RealmList<E> list) {
return (list.clazz == null)
? new RealmQuery(list.realm, list.getOsList(), list.className)
: new RealmQuery(list.realm, list.getOsList(), list.clazz);
}
private static boolean isClassForRealmModel(Class<?> clazz) {
return RealmModel.class.isAssignableFrom(clazz);
}
private RealmQuery(Realm realm, Class<E> clazz) {
this.realm = realm;
this.clazz = clazz;
this.forValues = !isClassForRealmModel(clazz);
if (forValues) {
this.schema = null;
this.table = null;
this.osList = null;
this.query = null;
} else {
this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
this.table = schema.getTable();
this.osList = null;
this.query = table.where();
}
}
private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
this.realm = queryResults.realm;
this.clazz = clazz;
this.forValues = !isClassForRealmModel(clazz);
if (forValues) {
this.schema = null;
this.table = null;
this.osList = null;
this.query = null;
} else {
this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
this.table = queryResults.getTable();
this.osList = null;
this.query = queryResults.getOsResults().where();
}
}
private RealmQuery(BaseRealm realm, OsList osList, Class<E> clazz) {
this.realm = realm;
this.clazz = clazz;
this.forValues = !isClassForRealmModel(clazz);
if (forValues) {
this.schema = null;
this.table = null;
this.osList = null;
this.query = null;
} else {
this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
this.table = schema.getTable();
this.osList = osList;
this.query = osList.getQuery();
}
}
private RealmQuery(BaseRealm realm, String className) {
this.realm = realm;
this.className = className;
this.forValues = false;
this.schema = realm.getSchema().getSchemaForClass(className);
this.table = schema.getTable();
this.query = table.where();
this.osList = null;
}
private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
this.realm = queryResults.realm;
this.className = className;
this.forValues = false;
this.schema = realm.getSchema().getSchemaForClass(className);
this.table = schema.getTable();
this.query = queryResults.getOsResults().where();
this.osList = null;
}
private RealmQuery(BaseRealm realm, OsList osList, String className) {
this.realm = realm;
this.className = className;
this.forValues = false;
this.schema = realm.getSchema().getSchemaForClass(className);
this.table = schema.getTable();
this.query = osList.getQuery();
this.osList = osList;
}
public boolean isValid() {
if (realm == null || realm.isClosed() /* this includes thread checking */) {
return false;
}
if (osList != null) {
return osList.isValid();
}
return table != null && table.isValid();
}
public RealmQuery<E> isNull(String fieldName) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName);
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
return this;
}
public RealmQuery<E> isNotNull(String fieldName) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName);
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable String value) {
return this.equalTo(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> equalTo(String fieldName, @Nullable String value, Case casing) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value, casing);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable String value, Case casing) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Byte value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Byte value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable byte[] value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Short value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Short value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Integer value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Integer value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Long value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Long value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Double value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Double value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Float value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Float value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Boolean value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Boolean value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
if (value == null) {
this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> equalTo(String fieldName, @Nullable Date value) {
realm.checkIfValid();
return equalToWithoutThreadValidation(fieldName, value);
}
private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Date value) {
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> in(String fieldName, @Nullable String[] values) {
return in(fieldName, values, Case.SENSITIVE);
}
public RealmQuery<E> in(String fieldName, @Nullable String[] values, Case casing) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
}
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0], casing);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i], casing);
}
return endGroupWithoutThreadValidation();
}
public RealmQuery<E> in(String fieldName, @Nullable Byte[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Short[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Integer[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Long[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Double[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Float[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Boolean[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> in(String fieldName, @Nullable Date[] values) {
realm.checkIfValid();
if (values == null || values.length == 0) {
alwaysFalse();
return this;
} else {
beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
for (int i = 1; i < values.length; i++) {
orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
}
return endGroupWithoutThreadValidation();
}
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable String value) {
return this.notEqualTo(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable String value, Case casing) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
if (fd.length() > 1 && !casing.getValue()) {
throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
}
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Byte value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable byte[] value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Short value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Integer value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Long value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Double value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Float value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Boolean value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), !value);
}
return this;
}
public RealmQuery<E> notEqualTo(String fieldName, @Nullable Date value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
if (value == null) {
this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
} else {
this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
}
return this;
}
public RealmQuery<E> greaterThan(String fieldName, int value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThan(String fieldName, long value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThan(String fieldName, double value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThan(String fieldName, float value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThan(String fieldName, Date value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThan(String fieldName, int value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThan(String fieldName, long value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThan(String fieldName, double value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThan(String fieldName, float value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThan(String fieldName, Date value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
return this;
}
public RealmQuery<E> between(String fieldName, int from, int to) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.between(fd.getColumnIndices(), from, to);
return this;
}
public RealmQuery<E> between(String fieldName, long from, long to) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
this.query.between(fd.getColumnIndices(), from, to);
return this;
}
public RealmQuery<E> between(String fieldName, double from, double to) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
this.query.between(fd.getColumnIndices(), from, to);
return this;
}
public RealmQuery<E> between(String fieldName, float from, float to) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
this.query.between(fd.getColumnIndices(), from, to);
return this;
}
public RealmQuery<E> between(String fieldName, Date from, Date to) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
this.query.between(fd.getColumnIndices(), from, to);
return this;
}
public RealmQuery<E> contains(String fieldName, String value) {
return contains(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> contains(String fieldName, String value, Case casing) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
this.query.contains(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> beginsWith(String fieldName, String value) {
return beginsWith(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
this.query.beginsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> endsWith(String fieldName, String value) {
return endsWith(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
this.query.endsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> like(String fieldName, String value) {
return like(fieldName, value, Case.SENSITIVE);
}
public RealmQuery<E> like(String fieldName, String value, Case casing) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
this.query.like(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
return this;
}
public RealmQuery<E> beginGroup() {
realm.checkIfValid();
return beginGroupWithoutThreadValidation();
}
private RealmQuery<E> beginGroupWithoutThreadValidation() {
this.query.group();
return this;
}
public RealmQuery<E> endGroup() {
realm.checkIfValid();
return endGroupWithoutThreadValidation();
}
private RealmQuery<E> endGroupWithoutThreadValidation() {
this.query.endGroup();
return this;
}
public RealmQuery<E> or() {
realm.checkIfValid();
return orWithoutThreadValidation();
}
private RealmQuery<E> orWithoutThreadValidation() {
this.query.or();
return this;
}
public RealmQuery<E> and() {
realm.checkIfValid();
return this;
}
public RealmQuery<E> not() {
realm.checkIfValid();
this.query.not();
return this;
}
public RealmQuery<E> isEmpty(String fieldName) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
this.query.isEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
return this;
}
public RealmQuery<E> isNotEmpty(String fieldName) {
realm.checkIfValid();
FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
this.query.isNotEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
return this;
}
public Number sum(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
switch (table.getColumnType(columnIndex)) {
case INTEGER:
return query.sumInt(columnIndex);
case FLOAT:
return query.sumFloat(columnIndex);
case DOUBLE:
return query.sumDouble(columnIndex);
default:
throw new IllegalArgumentException(String.format(Locale.US,
TYPE_MISMATCH, fieldName, "int, float or double"));
}
}
public double average(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
switch (table.getColumnType(columnIndex)) {
case INTEGER:
return query.averageInt(columnIndex);
case DOUBLE:
return query.averageDouble(columnIndex);
case FLOAT:
return query.averageFloat(columnIndex);
default:
throw new IllegalArgumentException(String.format(Locale.US,
TYPE_MISMATCH, fieldName, "int, float or double"));
}
}
@Nullable
public Number min(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
switch (table.getColumnType(columnIndex)) {
case INTEGER:
return this.query.minimumInt(columnIndex);
case FLOAT:
return this.query.minimumFloat(columnIndex);
case DOUBLE:
return this.query.minimumDouble(columnIndex);
default:
throw new IllegalArgumentException(String.format(Locale.US,
TYPE_MISMATCH, fieldName, "int, float or double"));
}
}
@Nullable
public Date minimumDate(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
return this.query.minimumDate(columnIndex);
}
@Nullable
public Number max(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
switch (table.getColumnType(columnIndex)) {
case INTEGER:
return this.query.maximumInt(columnIndex);
case FLOAT:
return this.query.maximumFloat(columnIndex);
case DOUBLE:
return this.query.maximumDouble(columnIndex);
default:
throw new IllegalArgumentException(String.format(Locale.US,
TYPE_MISMATCH, fieldName, "int, float or double"));
}
}
@Nullable
public Date maximumDate(String fieldName) {
realm.checkIfValid();
long columnIndex = schema.getAndCheckFieldIndex(fieldName);
return this.query.maximumDate(columnIndex);
}
public long count() {
realm.checkIfValid();
return lazyFindAll().size();
}
@SuppressWarnings("unchecked")
public RealmResults<E> findAll() {
realm.checkIfValid();
return createRealmResults(query, queryDescriptors, true, SubscriptionAction.NO_SUBSCRIPTION);
}
private OsResults lazyFindAll() {
realm.checkIfValid();
return createRealmResults(
query,
queryDescriptors,
false,
SubscriptionAction.NO_SUBSCRIPTION).osResults;
}
public RealmResults<E> findAllAsync() {
realm.checkIfValid();
realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
SubscriptionAction subscriptionAction;
if (realm.sharedRealm.isPartial() && osList == null) {
subscriptionAction = SubscriptionAction.ANONYMOUS_SUBSCRIPTION;
}  else {
subscriptionAction = SubscriptionAction.NO_SUBSCRIPTION;
}
return createRealmResults(query, queryDescriptors, false, subscriptionAction);
}
@ObjectServer
public RealmResults<E> findAllAsync(String subscriptionName) {
return findAllAsync(subscriptionName, Long.MAX_VALUE, TimeUnit.MILLISECONDS, false);
}
@ObjectServer
@Beta
public RealmResults<E> findAllAsync(String subscriptionName, boolean update) {
return findAllAsync(subscriptionName, Long.MAX_VALUE, TimeUnit.MILLISECONDS, update);
}
@ObjectServer
@Beta
public RealmResults<E> findAllAsync(String subscriptionName, long timeToLive, TimeUnit timeUnit) {
return findAllAsync(subscriptionName, timeToLive, timeUnit, false);
}
@ObjectServer
@Beta
public RealmResults<E> findAllAsync(String subscriptionName, long timeToLive, TimeUnit timeUnit, boolean update) {
realm.checkIfValid();
realm.checkIfPartialRealm();
if (osList != null) {
throw new IllegalStateException("Cannot create subscriptions for queries based on a 'RealmList'");
}
if (Util.isEmptyString(subscriptionName)) {
throw new IllegalArgumentException("Non-empty 'subscriptionName' required.");
}
if (timeToLive < 0) {
throw new IllegalArgumentException("Negative values for 'timeToLive' are not allowed: " + timeToLive);
}
if (timeUnit == null) {
throw new IllegalArgumentException("Non-null 'timeUnit' required.");
}
realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
long timeToLiveMs = timeUnit.toMillis(timeToLive);
SubscriptionAction action = (update) ? SubscriptionAction.update(subscriptionName, timeToLiveMs) : SubscriptionAction.create(subscriptionName, timeToLiveMs);
return createRealmResults(query, queryDescriptors, false, action);
}
public RealmQuery<E> sort(String fieldName) {
realm.checkIfValid();
return sort(fieldName, Sort.ASCENDING);
}
public RealmQuery<E> sort(String fieldName, Sort sortOrder) {
realm.checkIfValid();
return sort(new String[] { fieldName}, new Sort[] { sortOrder});
}
public RealmQuery<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
realm.checkIfValid();
return sort(new String[] { fieldName1, fieldName2 }, new Sort[] { sortOrder1, sortOrder2 });
}
public RealmQuery<E> sort(String[] fieldNames, Sort[] sortOrders) {
realm.checkIfValid();
QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
queryDescriptors.appendSort(sortDescriptor);
return this;
}
public RealmQuery<E> distinct(String fieldName) {
return distinct(fieldName, new String[]{});
}
public RealmQuery<E> distinct(String firstFieldName, String... remainingFieldNames) {
realm.checkIfValid();
QueryDescriptor distinctDescriptor;
if (remainingFieldNames.length == 0) {
distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);
} else {
String[] fieldNames = new String[1 + remainingFieldNames.length];
fieldNames[0] = firstFieldName;
System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
}
queryDescriptors.appendDistinct(distinctDescriptor);
return this;
}
public RealmQuery<E> limit(long limit) {
realm.checkIfValid();
if (limit < 1) {
throw new IllegalArgumentException("Only positive numbers above 0 is allowed. Yours was: " + limit);
}
queryDescriptors.setLimit(limit);
return this;
}
@ObjectServer
public RealmQuery<E> includeLinkingObjects(String firstIncludePath, @Nullable String... remainingFieldPaths) {
realm.checkIfValid();
if (!ObjectServerFacade.getSyncFacadeIfPossible().isPartialRealm(realm.getConfiguration())) {
throw new IllegalStateException("This method is only available for Query-based Realms.");
}
if (Util.isEmptyString(firstIncludePath)) {
throw new IllegalArgumentException("Non-empty 'firstIncludePath' required.");
}
queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, firstIncludePath));
if (remainingFieldPaths != null) {
for (int i = 0; i < remainingFieldPaths.length; i++) {
queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, remainingFieldPaths[i]));
}
}
return this;
}
public RealmQuery<E> alwaysTrue() {
realm.checkIfValid();
query.alwaysTrue();
return this;
}
public RealmQuery<E> alwaysFalse() {
realm.checkIfValid();
query.alwaysFalse();
return this;
}
public Realm getRealm() {
if (realm == null) {
return null;
}
realm.checkIfValid();
if (!(realm instanceof Realm)) {
throw new IllegalStateException("This method is only available for typed Realms");
}
return (Realm) realm;
}
@ObjectServer
@Beta
public Subscription subscribe() {
StringBuilder sb = new StringBuilder("[");
sb.append((table != null) ? table.getClassName() : "");
sb.append("] ");
sb.append(nativeSerializeQuery(query.getNativePtr(), queryDescriptors.getNativePtr()));
String name = sb.toString();
return subscribe(name);
}
@ObjectServer
@Beta
public Subscription subscribe(String name) {
return subscribe(name, Long.MAX_VALUE, TimeUnit.MILLISECONDS, false);
}
@ObjectServer
@Beta
public Subscription subscribe(String name, long timeToLive, TimeUnit timeUnit) {
return subscribe(name, timeToLive, timeUnit, false);
}
@ObjectServer
@Beta
public Subscription subscribeOrUpdate(String name) {
return subscribe(name, Long.MAX_VALUE, TimeUnit.MILLISECONDS, true);
}
@ObjectServer
@Beta
public Subscription subscribeOrUpdate(String name, long timeToLive, TimeUnit timeUnit) {
return subscribe(name, timeToLive, timeUnit, true);
}
@ObjectServer
private Subscription subscribe(String name, long timeToLive, TimeUnit timeUnit, boolean update) {
realm.checkIfValid();
if (realm instanceof DynamicRealm) {
throw new IllegalStateException("'subscribe' is not supported for queries on Dynamic Realms.");
}
if (osList != null) {
throw new IllegalStateException("Cannot create subscriptions for queries based on a 'RealmList. Subscribe to the object holding the list instead.'");
}
if (TextUtils.isEmpty(name)) {
throw new IllegalArgumentException("Non-empty 'name' required.");
}
if (timeUnit == null) {
throw new IllegalArgumentException("Non-null 'timeUnit' is required.");
}
long timeToLiveMs = TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);
long rowIndex = nativeSubscribe(realm.getSharedRealm().getNativePtr(), name, query.getNativePtr(),
queryDescriptors.getNativePtr(), timeToLiveMs, update);
CheckedRow row = ((Realm) realm).getTable(Subscription.class).getCheckedRow(rowIndex);
return realm.get(Subscription.class, null, row);
}
public String getDescription() {
return nativeSerializeQuery(query.getNativePtr(), queryDescriptors.getNativePtr());
}
public String getTypeQueried() {
return table.getClassName();
}
private boolean isDynamicQuery() {
return className != null;
}
@Nullable
public E findFirst() {
realm.checkIfValid();
if (forValues) {
return null;
}
long tableRowIndex = getSourceRowIndexForFirstObject();
return (tableRowIndex < 0) ? null : (E) realm.get((Class<? extends RealmModel>) clazz, className, tableRowIndex);
}
public E findFirstAsync() {
realm.checkIfValid();
if (forValues) {
throw new UnsupportedOperationException("findFirstAsync() available only when type parameter 'E' is implementing RealmModel.");
}
realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
Row row;
if (realm.isInTransaction()) {
row = OsResults.createFromQuery(realm.sharedRealm, query).firstUncheckedRow();
} else {
row = new PendingRow(realm.sharedRealm, query, queryDescriptors, isDynamicQuery());
}
final E result;
if (isDynamicQuery()) {
result = (E) new DynamicRealmObject(realm, row);
} else {
final Class<? extends RealmModel> modelClass = (Class<? extends RealmModel>) clazz;
result = (E) realm.getConfiguration().getSchemaMediator().newInstance(
modelClass, realm, row, realm.getSchema().getColumnInfo(modelClass),
false, Collections.<String>emptyList());
}
if (row instanceof PendingRow) {
final RealmObjectProxy proxy = (RealmObjectProxy) result;
((PendingRow) row).setFrontEnd(proxy.realmGet$proxyState());
}
return result;
}
private RealmResults<E> createRealmResults(TableQuery query,
DescriptorOrdering queryDescriptors,
boolean loadResults,
SubscriptionAction subscriptionAction) {
RealmResults<E> results;
OsResults osResults;
if (subscriptionAction.shouldCreateSubscriptions()) {
osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors, subscriptionAction);
} else {
osResults = OsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors);
}
if (isDynamicQuery()) {
results = new RealmResults<>(realm, osResults, className);
} else {
results = new RealmResults<>(realm, osResults, clazz);
}
if (loadResults) {
results.load();
}
return results;
}
private long getSourceRowIndexForFirstObject() {
if (!queryDescriptors.isEmpty()) {
RealmObjectProxy obj = (RealmObjectProxy) findAll().first(null);
if (obj != null) {
return obj.realmGet$proxyState().getRow$realm().getIndex();
} else {
return -1;
}
} else {
return this.query.find();
}
}
private SchemaConnector getSchemaConnector() {
return new SchemaConnector(realm.getSchema());
}
private static native String nativeSerializeQuery(long tableQueryPtr, long descriptorPtr);
private static native long nativeSubscribe(long sharedRealmPtr, String name, long tableQueryPtr,
long descriptorPtr, long timeToLiveMs, boolean update);
}
