package com.google.inject.internal;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import com.google.common.base.MoreObjects;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.inject.Binder;
import com.google.inject.Injector;
import com.google.inject.Key;
import com.google.inject.PrivateBinder;
import com.google.inject.spi.Element;
import com.google.inject.spi.ElementVisitor;
import com.google.inject.spi.PrivateElements;
import java.util.List;
import java.util.Map;
import java.util.Set;
public final class PrivateElementsImpl implements PrivateElements {
private final Object source;
private List<Element> elementsMutable = Lists.newArrayList();
private List<ExposureBuilder<?>> exposureBuilders = Lists.newArrayList();
private ImmutableList<Element> elements;
private ImmutableMap<Key<?>, Object> exposedKeysToSources;
private Injector injector;
public PrivateElementsImpl(Object source) {
this.source = checkNotNull(source, "source");
}
@Override
public Object getSource() {
return source;
}
@Override
public List<Element> getElements() {
if (elements == null) {
elements = ImmutableList.copyOf(elementsMutable);
elementsMutable = null;
}
return elements;
}
@Override
public Injector getInjector() {
return injector;
}
public void initInjector(Injector injector) {
checkState(this.injector == null, "injector already initialized");
this.injector = checkNotNull(injector, "injector");
}
@Override
public Set<Key<?>> getExposedKeys() {
if (exposedKeysToSources == null) {
Map<Key<?>, Object> exposedKeysToSourcesMutable = Maps.newLinkedHashMap();
for (ExposureBuilder<?> exposureBuilder : exposureBuilders) {
exposedKeysToSourcesMutable.put(exposureBuilder.getKey(), exposureBuilder.getSource());
}
exposedKeysToSources = ImmutableMap.copyOf(exposedKeysToSourcesMutable);
exposureBuilders = null;
}
return exposedKeysToSources.keySet();
}
@Override
public <T> T acceptVisitor(ElementVisitor<T> visitor) {
return visitor.visit(this);
}
public List<Element> getElementsMutable() {
return elementsMutable;
}
public void addExposureBuilder(ExposureBuilder<?> exposureBuilder) {
exposureBuilders.add(exposureBuilder);
}
@Override
public void applyTo(Binder binder) {
PrivateBinder privateBinder = binder.withSource(source).newPrivateBinder();
for (Element element : getElements()) {
element.applyTo(privateBinder);
}
getExposedKeys(); 
for (Map.Entry<Key<?>, Object> entry : exposedKeysToSources.entrySet()) {
privateBinder.withSource(entry.getValue()).expose(entry.getKey());
}
}
@Override
public Object getExposedSource(Key<?> key) {
getExposedKeys(); 
Object source = exposedKeysToSources.get(key);
checkArgument(source != null, "%s not exposed by %s.", key, this);
return source;
}
@Override
public String toString() {
return MoreObjects.toStringHelper(PrivateElements.class)
.add("exposedKeys", getExposedKeys())
.add("source", getSource())
.toString();
}
}
