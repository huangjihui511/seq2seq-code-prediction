package spark.utils;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
public class MimeParse {
public static final String NO_MIME_TYPE = "";
private static class ParseResults {
String type;
String subType;
Map<String, String> params;
@Override
public String toString() {
StringBuffer s = new StringBuffer("('" + type + "', '" + subType + "', {");
for (String k : params.keySet()) {
s.append("'" + k + "':'" + params.get(k) + "',");
}
return s.append("})").toString();
}
}
private static ParseResults parseMimeType(String mimeType) {
String[] parts = mimeType.split(";");
ParseResults results = new ParseResults();
results.params = new HashMap<>();
for (int i = 1; i < parts.length; ++i) {
String p = parts[i];
String[] subParts = p.split("=");
if (subParts.length == 2) {
results.params.put(subParts[0].trim(), subParts[1].trim());
}
}
String fullType = parts[0].trim();
if (fullType.equals("*")) {
fullType = "*/*";
}
int slashIndex = fullType.indexOf('/');
if (slashIndex != -1) {
results.type = fullType.substring(0, slashIndex);
results.subType = fullType.substring(slashIndex + 1);
} else {
results.type = fullType;
results.subType = "*";
}
return results;
}
private static ParseResults parseMediaRange(String range) {
ParseResults results = parseMimeType(range);
String q = results.params.get("q");
float f = toFloat(q, 1);
if (isBlank(q) || f < 0 || f > 1) {
results.params.put("q", "1");
}
return results;
}
private static class FitnessAndQuality implements Comparable<FitnessAndQuality> {
int fitness;
float quality;
String mimeType; 
private FitnessAndQuality(int fitness, float quality) {
this.fitness = fitness;
this.quality = quality;
}
public int compareTo(FitnessAndQuality o) {
if (fitness == o.fitness) {
if (quality == o.quality) {
return 0;
} else {
return quality < o.quality ? -1 : 1;
}
} else {
return fitness < o.fitness ? -1 : 1;
}
}
}
private static FitnessAndQuality fitnessAndQualityParsed(String mimeType, Collection<ParseResults> parsedRanges) {
int bestFitness = -1;
float bestFitQ = 0;
ParseResults target = parseMediaRange(mimeType);
for (ParseResults range : parsedRanges) {
if ((target.type.equals(range.type) || range.type.equals("*") || target.type.equals("*"))
&& (target.subType.equals(range.subType) || range.subType.equals("*")
|| target.subType.equals("*"))) {
for (String k : target.params.keySet()) {
int paramMatches = 0;
if (!k.equals("q") && range.params.containsKey(k)
&& target.params.get(k).equals(range.params.get(k))) {
paramMatches++;
}
int fitness = (range.type.equals(target.type)) ? 100 : 0;
fitness += (range.subType.equals(target.subType)) ? 10 : 0;
fitness += paramMatches;
if (fitness > bestFitness) {
bestFitness = fitness;
bestFitQ = toFloat(range.params.get("q"), 0);
}
}
}
}
return new FitnessAndQuality(bestFitness, bestFitQ);
}
public static String bestMatch(Collection<String> supported, String header) {
List<ParseResults> parseResults = new LinkedList<>();
List<FitnessAndQuality> weightedMatches = new LinkedList<>();
for (String r : header.split(",")) {
parseResults.add(parseMediaRange(r));
}
for (String s : supported) {
FitnessAndQuality fitnessAndQuality = fitnessAndQualityParsed(s, parseResults);
fitnessAndQuality.mimeType = s;
weightedMatches.add(fitnessAndQuality);
}
Collections.sort(weightedMatches);
FitnessAndQuality lastOne = weightedMatches.get(weightedMatches.size() - 1);
return Float.compare(lastOne.quality, 0) != 0 ? lastOne.mimeType : NO_MIME_TYPE;
}
private static boolean isBlank(String s) {
return s == null || "".equals(s.trim());
}
private static float toFloat(final String str, final float defaultValue) {
if (str == null) {
return defaultValue;
}
try {
return Float.parseFloat(str);
} catch (final NumberFormatException nfe) {
return defaultValue;
}
}
private MimeParse() {
}
}
