"[[\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) {\", \"int rows = ( ( ArrayResult ) this . getAllResultData ( )\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( )\", \". get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ;\", \"int columns =\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns =\", \"0 ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ;\", \"for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) {\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) {\", \"columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ;\", \"}\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n }\", \"int [ ] [ ] resultData = new int [ rows ] [ columns ] ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ;\", \"int columnsDone = 0 ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ;\", \"for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) {\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) {\", \"int [ ] [ ] work =\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work =\", \"( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ;\", \"for ( int m = 0 ; m < work . length ; m ++ ) {\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) {\", \"for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) {\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) {\", \"resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ;\", \"}\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n }\", \"}\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n } \\n }\", \"columnsDone += work [ 0 ] . length ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n } \\n } \\n columnsDone += work [ 0 ] . length ;\", \"}\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n } \\n } \\n columnsDone += work [ 0 ] . length ; \\n }\", \"return new ArrayResult ( resultData ) ;\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n } \\n } \\n columnsDone += work [ 0 ] . length ; \\n } \\n return new ArrayResult ( resultData ) ;\", \"}\"], [\"@ Override \\n ArrayList < Worker > setWorkers ( int num ) { \\n ArrayList < Worker > ws = new ArrayList < Worker > ( num ) ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n ws . add ( new ArrayTransposeWorker ( this , i + 1 ) ) ; \\n } \\n return ws ; \\n } \\n @ Override \\n ArrayResult aggregateData ( ) { \\n int rows = ( ( ArrayResult ) this . getAllResultData ( ) \\n . get ( this . getAllResultData ( ) . keys ( ) . nextElement ( ) ) ) . data . length ; \\n int columns = \\n 0 ; \\n for ( Enumeration < Integer > e = this . getAllResultData ( ) . keys ( ) ; e . hasMoreElements ( ) ; ) { \\n columns += ( ( ArrayResult ) this . getAllResultData ( ) . get ( e . nextElement ( ) ) ) . data [ 0 ] . length ; \\n } \\n int [ ] [ ] resultData = new int [ rows ] [ columns ] ; \\n int columnsDone = 0 ; \\n for ( int i = 0 ; i < this . getExpectedNumResults ( ) ; i ++ ) { \\n int [ ] [ ] work = \\n ( ( ArrayResult ) this . getAllResultData ( ) . get ( this . getWorkers ( ) . get ( i ) . getWorkerId ( ) ) ) . data ; \\n for ( int m = 0 ; m < work . length ; m ++ ) { \\n for ( int n = 0 ; n < work [ 0 ] . length ; n ++ ) { \\n resultData [ m ] [ columnsDone + n ] = work [ m ] [ n ] ; \\n } \\n } \\n columnsDone += work [ 0 ] . length ; \\n } \\n return new ArrayResult ( resultData ) ; \\n }\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) {\", \"return this . finalResult ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n }\", \"Hashtable < Integer , Result > getAllResultData ( ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) {\", \"return this . allResultData ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n }\", \"int getExpectedNumResults ( ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) {\", \"return this . expectedNumResults ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n }\", \"ArrayList < Worker > getWorkers ( ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) {\", \"return this . workers ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n }\", \"abstract ArrayList < Worker > setWorkers ( int num ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ;\", \"public void doWork ( Input input ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) {\", \"divideWork ( input ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n }\", \"private void divideWork ( Input input ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) {\", \"ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ;\", \"if ( dividedInput != null ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) {\", \"this . expectedNumResults = dividedInput . size ( ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ;\", \"for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) {\", \"this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ;\", \"this . workers . get ( i ) . run ( ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n }\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n }\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n }\", \"public void receiveData ( Result data , Worker w ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) {\", \"collectResult ( data , w . getWorkerId ( ) ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n }\", \"private void collectResult ( Result data , int workerId ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) {\", \"this . allResultData . put ( workerId , data ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ;\", \"if ( this . allResultData . size ( ) == this . expectedNumResults ) {\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ; \\n if ( this . allResultData . size ( ) == this . expectedNumResults ) {\", \"this . finalResult = aggregateData ( ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ; \\n if ( this . allResultData . size ( ) == this . expectedNumResults ) { \\n this . finalResult = aggregateData ( ) ;\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ; \\n if ( this . allResultData . size ( ) == this . expectedNumResults ) { \\n this . finalResult = aggregateData ( ) ; \\n }\", \"}\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ; \\n if ( this . allResultData . size ( ) == this . expectedNumResults ) { \\n this . finalResult = aggregateData ( ) ; \\n } \\n }\", \"abstract Result aggregateData ( ) ;\"], [\"private Hashtable < Integer , Result > allResultData ; \\n private Result finalResult ; \\n Master ( int numOfWorkers ) { \\n this . numOfWorkers = numOfWorkers ; \\n this . workers = setWorkers ( numOfWorkers ) ; \\n this . expectedNumResults = 0 ; \\n this . allResultData = new Hashtable < Integer , Result > ( numOfWorkers ) ; \\n this . finalResult = null ; \\n } \\n public Result getFinalResult ( ) { \\n return this . finalResult ; \\n } \\n Hashtable < Integer , Result > getAllResultData ( ) { \\n return this . allResultData ; \\n } \\n int getExpectedNumResults ( ) { \\n return this . expectedNumResults ; \\n } \\n ArrayList < Worker > getWorkers ( ) { \\n return this . workers ; \\n } \\n abstract ArrayList < Worker > setWorkers ( int num ) ; \\n public void doWork ( Input input ) { \\n divideWork ( input ) ; \\n } \\n private void divideWork ( Input input ) { \\n ArrayList < Input > dividedInput = input . divideData ( numOfWorkers ) ; \\n if ( dividedInput != null ) { \\n this . expectedNumResults = dividedInput . size ( ) ; \\n for ( int i = 0 ; i < this . expectedNumResults ; i ++ ) { \\n this . workers . get ( i ) . setReceivedData ( this , dividedInput . get ( i ) ) ; \\n this . workers . get ( i ) . run ( ) ; \\n } \\n } \\n } \\n public void receiveData ( Result data , Worker w ) { \\n collectResult ( data , w . getWorkerId ( ) ) ; \\n } \\n private void collectResult ( Result data , int workerId ) { \\n this . allResultData . put ( workerId , data ) ; \\n if ( this . allResultData . size ( ) == this . expectedNumResults ) { \\n this . finalResult = aggregateData ( ) ; \\n } \\n } \\n abstract Result aggregateData ( ) ;\", \"}\"], [\"} \\n @ Override \\n public void partyAction ( Action action ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action . getDescription ( ) ) ; \\n } \\n @ Override \\n public void act ( Action action ) { \\n if ( party != null ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action ) ; \\n party . act ( this , action ) ;\", \"}\"], [\"} \\n @ Override \\n public void partyAction ( Action action ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action . getDescription ( ) ) ; \\n } \\n @ Override \\n public void act ( Action action ) { \\n if ( party != null ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action ) ; \\n party . act ( this , action ) ; \\n }\", \"}\"], [\"} \\n @ Override \\n public void partyAction ( Action action ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action . getDescription ( ) ) ; \\n } \\n @ Override \\n public void act ( Action action ) { \\n if ( party != null ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action ) ; \\n party . act ( this , action ) ; \\n } \\n }\", \"@ Override\"], [\"} \\n @ Override \\n public void partyAction ( Action action ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action . getDescription ( ) ) ; \\n } \\n @ Override \\n public void act ( Action action ) { \\n if ( party != null ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action ) ; \\n party . act ( this , action ) ; \\n } \\n } \\n @ Override\", \"public abstract String toString ( ) ;\"], [\"} \\n @ Override \\n public void partyAction ( Action action ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action . getDescription ( ) ) ; \\n } \\n @ Override \\n public void act ( Action action ) { \\n if ( party != null ) { \\n LOGGER . info ( \\\"{} {}\\\" , this , action ) ; \\n party . act ( this , action ) ; \\n } \\n } \\n @ Override \\n public abstract String toString ( ) ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else {\", \"l ++ ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n }\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n }\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n }\", \"return divisions ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n }\", \"@ Override\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override\", \"public ArrayList < Input > divideData ( int num ) {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) {\", \"if ( this . data == null ) {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) {\", \"return null ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ;\", \"} else {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else {\", \"int [ ] divisions = makeDivisions ( this . data , num ) ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ;\", \"ArrayList < Input > result = new ArrayList < Input > ( num ) ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ;\", \"int rowsDone = 0 ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ;\", \"for ( int i = 0 ; i < num ; i ++ ) {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) {\", \"int rows = divisions [ i ] ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ;\", \"if ( rows != 0 ) {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) {\", \"int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ;\", \"for ( int j = 0 ; j < rows ; j ++ ) {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) {\", \"divided [ j ] = this . data [ rowsDone + j ] ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n }\", \"rowsDone += rows ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ;\", \"ArrayInput dividedInput = new ArrayInput ( divided ) ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ;\", \"result . add ( dividedInput ) ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ;\", \"} else {\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else {\", \"break ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ; \\n }\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ; \\n } \\n }\", \"return result ;\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ; \\n } \\n } \\n return result ;\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ; \\n } \\n } \\n return result ; \\n }\", \"}\"], [\"Arrays . fill ( divisions , initialDivision ) ; \\n if ( initialDivision * num != data . length ) { \\n int extra = data . length - initialDivision * num ; \\n int l = 0 ; \\n while ( extra > 0 ) { \\n divisions [ l ] = divisions [ l ] + 1 ; \\n extra -- ; \\n if ( l == num - 1 ) { \\n l = 0 ; \\n } else { \\n l ++ ; \\n } \\n } \\n } \\n return divisions ; \\n } \\n @ Override \\n public ArrayList < Input > divideData ( int num ) { \\n if ( this . data == null ) { \\n return null ; \\n } else { \\n int [ ] divisions = makeDivisions ( this . data , num ) ; \\n ArrayList < Input > result = new ArrayList < Input > ( num ) ; \\n int rowsDone = 0 ; \\n for ( int i = 0 ; i < num ; i ++ ) { \\n int rows = divisions [ i ] ; \\n if ( rows != 0 ) { \\n int [ ] [ ] divided = new int [ rows ] [ this . data [ 0 ] . length ] ; \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n divided [ j ] = this . data [ rowsDone + j ] ; \\n } \\n rowsDone += rows ; \\n ArrayInput dividedInput = new ArrayInput ( divided ) ; \\n result . add ( dividedInput ) ; \\n } else { \\n break ; \\n } \\n } \\n return result ; \\n } \\n }\", \"}\"], [\"for ( PartyMember member : members ) { \\n if ( ! member . equals ( actor ) ) { \\n member . partyAction ( action ) ; \\n } \\n } \\n } \\n @ Override \\n public void addMember ( PartyMember member ) { \\n members . add ( member ) ; \\n member . joinedParty ( this ) ;\", \"}\"], [\"for ( PartyMember member : members ) { \\n if ( ! member . equals ( actor ) ) { \\n member . partyAction ( action ) ; \\n } \\n } \\n } \\n @ Override \\n public void addMember ( PartyMember member ) { \\n members . add ( member ) ; \\n member . joinedParty ( this ) ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n }\", \"return answer ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n }\", \"public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) {\", \"if ( m1 . length != m2 . length ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) {\", \"return false ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ;\", \"} else {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else {\", \"boolean answer = false ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ;\", \"for ( int i = 0 ; i < m1 . length ; i ++ ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) {\", \"if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) {\", \"answer = true ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ;\", \"} else {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else {\", \"answer = false ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ;\", \"break ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n }\", \"return answer ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n }\", \"public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) {\", \"int [ ] [ ] matrix = new int [ rows ] [ columns ] ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ;\", \"for ( int i = 0 ; i < rows ; i ++ ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) {\", \"for ( int j = 0 ; j < columns ; j ++ ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) {\", \"matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n }\", \"return matrix ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n }\", \"public static void printMatrix ( int [ ] [ ] matrix ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) {\", \"for ( int i = 0 ; i < matrix . length ; i ++ ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) {\", \"for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) {\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) {\", \"LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { \\n LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { \\n LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ; \\n }\", \"LOGGER . info ( \\\"\\\" ) ;\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { \\n LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ; \\n } \\n LOGGER . info ( \\\"\\\" ) ;\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { \\n LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ; \\n } \\n LOGGER . info ( \\\"\\\" ) ; \\n }\", \"}\"], [\"} else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < a1 . length ; i ++ ) { \\n if ( a1 [ i ] == a2 [ i ] ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static boolean matricesSame ( int [ ] [ ] m1 , int [ ] [ ] m2 ) { \\n if ( m1 . length != m2 . length ) { \\n return false ; \\n } else { \\n boolean answer = false ; \\n for ( int i = 0 ; i < m1 . length ; i ++ ) { \\n if ( arraysSame ( m1 [ i ] , m2 [ i ] ) ) { \\n answer = true ; \\n } else { \\n answer = false ; \\n break ; \\n } \\n } \\n return answer ; \\n } \\n } \\n public static int [ ] [ ] createRandomIntMatrix ( int rows , int columns ) { \\n int [ ] [ ] matrix = new int [ rows ] [ columns ] ; \\n for ( int i = 0 ; i < rows ; i ++ ) { \\n for ( int j = 0 ; j < columns ; j ++ ) { \\n matrix [ i ] [ j ] = RANDOM . nextInt ( 10 ) ; \\n } \\n } \\n return matrix ; \\n } \\n public static void printMatrix ( int [ ] [ ] matrix ) { \\n for ( int i = 0 ; i < matrix . length ; i ++ ) { \\n for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { \\n LOGGER . info ( matrix [ i ] [ j ] + \\\" \\\" ) ; \\n } \\n LOGGER . info ( \\\"\\\" ) ; \\n } \\n }\", \"}\"], [\"ArrayInput arrayInput = ( ArrayInput ) this . getReceivedData ( ) ; \\n final int rows = arrayInput . data [ 0 ] . length ; \\n final int cols = arrayInput . data . length ; \\n int [ ] [ ] resultData = new int [ rows ] [ cols ] ; \\n for ( int i = 0 ; i < cols ; i ++ ) { \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n resultData [ j ] [ i ] = arrayInput . data [ i ] [ j ] ; \\n } \\n } \\n return new ArrayResult ( resultData ) ;\", \"}\"], [\"ArrayInput arrayInput = ( ArrayInput ) this . getReceivedData ( ) ; \\n final int rows = arrayInput . data [ 0 ] . length ; \\n final int cols = arrayInput . data . length ; \\n int [ ] [ ] resultData = new int [ rows ] [ cols ] ; \\n for ( int i = 0 ; i < cols ; i ++ ) { \\n for ( int j = 0 ; j < rows ; j ++ ) { \\n resultData [ j ] [ i ] = arrayInput . data [ i ] [ j ] ; \\n } \\n } \\n return new ArrayResult ( resultData ) ; \\n }\", \"}\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) {\", \"this . receivedData = i ;\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ;\", \"}\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n }\", \"abstract Result executeOperation ( ) ;\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ;\", \"private void sendToMaster ( Result data ) {\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) {\", \"this . master . receiveData ( data , this ) ;\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ;\", \"}\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ; \\n }\", \"public void run ( ) {\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ; \\n } \\n public void run ( ) {\", \"Result work = executeOperation ( ) ;\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ; \\n } \\n public void run ( ) { \\n Result work = executeOperation ( ) ;\", \"sendToMaster ( work ) ;\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ; \\n } \\n public void run ( ) { \\n Result work = executeOperation ( ) ; \\n sendToMaster ( work ) ;\", \"}\"], [\"this . workerId = id ; \\n this . receivedData = null ; \\n } \\n public int getWorkerId ( ) { \\n return this . workerId ; \\n } \\n Input getReceivedData ( ) { \\n return this . receivedData ; \\n } \\n public void setReceivedData ( Master m , Input i ) { \\n this . receivedData = i ; \\n } \\n abstract Result executeOperation ( ) ; \\n private void sendToMaster ( Result data ) { \\n this . master . receiveData ( data , this ) ; \\n } \\n public void run ( ) { \\n Result work = executeOperation ( ) ; \\n sendToMaster ( work ) ; \\n }\", \"}\"], [\"processCommand ( ) ; \\n System . out . println ( Thread . currentThread ( ) . getName ( ) + \\\" End. Time = \\\" + new Date ( ) ) ; \\n } \\n private void processCommand ( ) { \\n try { \\n Thread . sleep ( 5000 ) ; \\n } catch ( InterruptedException e ) { \\n e . printStackTrace ( ) ; \\n } \\n }\", \"@ Override\"], [\"processCommand ( ) ; \\n System . out . println ( Thread . currentThread ( ) . getName ( ) + \\\" End. Time = \\\" + new Date ( ) ) ; \\n } \\n private void processCommand ( ) { \\n try { \\n Thread . sleep ( 5000 ) ; \\n } catch ( InterruptedException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n @ Override\", \"public String toString ( ) {\"], [\"processCommand ( ) ; \\n System . out . println ( Thread . currentThread ( ) . getName ( ) + \\\" End. Time = \\\" + new Date ( ) ) ; \\n } \\n private void processCommand ( ) { \\n try { \\n Thread . sleep ( 5000 ) ; \\n } catch ( InterruptedException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n @ Override \\n public String toString ( ) {\", \"return this . command ;\"], [\"processCommand ( ) ; \\n System . out . println ( Thread . currentThread ( ) . getName ( ) + \\\" End. Time = \\\" + new Date ( ) ) ; \\n } \\n private void processCommand ( ) { \\n try { \\n Thread . sleep ( 5000 ) ; \\n } catch ( InterruptedException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n @ Override \\n public String toString ( ) { \\n return this . command ;\", \"}\"], [\"processCommand ( ) ; \\n System . out . println ( Thread . currentThread ( ) . getName ( ) + \\\" End. Time = \\\" + new Date ( ) ) ; \\n } \\n private void processCommand ( ) { \\n try { \\n Thread . sleep ( 5000 ) ; \\n } catch ( InterruptedException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n @ Override \\n public String toString ( ) { \\n return this . command ; \\n }\", \"}\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ;\", \"}\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n }\", \"executor . shutdown ( ) ;\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n } \\n executor . shutdown ( ) ;\", \"while ( ! executor . isTerminated ( ) ) {\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n } \\n executor . shutdown ( ) ; \\n while ( ! executor . isTerminated ( ) ) {\", \"}\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n } \\n executor . shutdown ( ) ; \\n while ( ! executor . isTerminated ( ) ) { \\n }\", \"System . out . println ( \\\"Finished all threads\\\" ) ;\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n } \\n executor . shutdown ( ) ; \\n while ( ! executor . isTerminated ( ) ) { \\n } \\n System . out . println ( \\\"Finished all threads\\\" ) ;\", \"}\"], [\"ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Runnable worker = new MyRunnable ( \\\"\\\" + i ) ; \\n executor . execute ( worker ) ; \\n } \\n executor . shutdown ( ) ; \\n while ( ! executor . isTerminated ( ) ) { \\n } \\n System . out . println ( \\\"Finished all threads\\\" ) ; \\n }\", \"}\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME ,\", \"TimeUnit . SECONDS ,\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS ,\", \"new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) ,\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) ,\", \"new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;\", \"List < Future < String > > futureList = new ArrayList < > ( ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ;\", \"Callable < String > callable = new MyCallable ( ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ;\", \"for ( int i = 0 ; i < 10 ; i ++ ) {\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) {\", \"Future < String > future = executor . submit ( callable ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ;\", \"futureList . add ( future ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ;\", \"}\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n }\", \"for ( Future < String > fut : futureList ) {\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) {\", \"try {\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try {\", \"System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ;\", \"} catch ( InterruptedException | ExecutionException e ) {\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) {\", \"e . printStackTrace ( ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) { \\n e . printStackTrace ( ) ;\", \"}\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) { \\n e . printStackTrace ( ) ; \\n }\", \"}\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) { \\n e . printStackTrace ( ) ; \\n } \\n }\", \"executor . shutdown ( ) ;\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n executor . shutdown ( ) ;\", \"}\"], [\"import static common . ThreadPoolConstants . CORE_POOL_SIZE ; \\n import static common . ThreadPoolConstants . KEEP_ALIVE_TIME ; \\n import static common . ThreadPoolConstants . MAX_POOL_SIZE ; \\n import static common . ThreadPoolConstants . QUEUE_CAPACITY ; \\n public class CallableDemo { \\n public static void main ( String [ ] args ) { \\n ThreadPoolExecutor executor = new ThreadPoolExecutor ( \\n CORE_POOL_SIZE , \\n MAX_POOL_SIZE , \\n KEEP_ALIVE_TIME , \\n TimeUnit . SECONDS , \\n new ArrayBlockingQueue < > ( QUEUE_CAPACITY ) , \\n new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; \\n List < Future < String > > futureList = new ArrayList < > ( ) ; \\n Callable < String > callable = new MyCallable ( ) ; \\n for ( int i = 0 ; i < 10 ; i ++ ) { \\n Future < String > future = executor . submit ( callable ) ; \\n futureList . add ( future ) ; \\n } \\n for ( Future < String > fut : futureList ) { \\n try { \\n System . out . println ( new Date ( ) + \\\"::\\\" + fut . get ( ) ) ; \\n } catch ( InterruptedException | ExecutionException e ) { \\n e . printStackTrace ( ) ; \\n } \\n } \\n executor . shutdown ( ) ; \\n }\", \"}\"]]"